import { InstrumentEntity } from 'src/models/entities/instrument.entity';
import { InstrumentRepository } from 'src/models/repositories/instrument.repository';
import { ContractDto, ContractListDto, UpdateContractDto } from 'src/modules/instrument/dto/create-instrument.dto';
import { UpdateInstrumentDto } from 'src/modules/instrument/dto/update-instrument.dto';
import { GetInstrumentDto } from './dto/get-instrument.dto';
import { MarketFeeRepository } from '../../models/repositories/market_fee.repository';
import { MarketFeeEntity } from '../../models/entities/market_fee.entity';
import { CreateMarketFeeDto } from './dto/create-market-free.dto';
import { UpdateMarketFeeDto } from './dto/update-market-fee.dto';
import { TradingRulesRepository } from 'src/models/repositories/trading-rules.repository';
import { LeverageMarginRepository } from 'src/models/repositories/leverage-margin.repository';
import { Connection } from 'typeorm';
import { TradingRulesEntity } from 'src/models/entities/trading_rules.entity';
import { LeverageMarginEntity } from 'src/models/entities/leverage-margin.entity';
import { Cache } from 'cache-manager';
import { KafkaClient } from 'src/shares/kafka-client/kafka-client';
import { RedisService } from 'nestjs-redis';
import { ContractType } from 'src/shares/enums/order.enum';
import { AccountRepository } from 'src/models/repositories/account.repository';
import { Producer } from 'kafkajs';
import { FundingService } from '../funding/funding.service';
export declare class InstrumentService {
    readonly instrumentRepoReport: InstrumentRepository;
    readonly instrumentRepoMaster: InstrumentRepository;
    readonly marketFeeRepoReport: MarketFeeRepository;
    readonly marketFeeRepoMaster: MarketFeeRepository;
    readonly accountRepositoryMaster: AccountRepository;
    readonly accountRepositoryReport: AccountRepository;
    private tradingRulesMaster;
    private readonly tradingRulesReport;
    readonly leverageMarginRepoReport: LeverageMarginRepository;
    readonly leverageMarginRepoMaster: LeverageMarginRepository;
    private connection;
    private cacheManager;
    private readonly redisService;
    readonly kafkaClient: KafkaClient;
    private readonly fundingService;
    constructor(instrumentRepoReport: InstrumentRepository, instrumentRepoMaster: InstrumentRepository, marketFeeRepoReport: MarketFeeRepository, marketFeeRepoMaster: MarketFeeRepository, accountRepositoryMaster: AccountRepository, accountRepositoryReport: AccountRepository, tradingRulesMaster: TradingRulesRepository, tradingRulesReport: TradingRulesRepository, leverageMarginRepoReport: LeverageMarginRepository, leverageMarginRepoMaster: LeverageMarginRepository, connection: Connection, cacheManager: Cache, redisService: RedisService, kafkaClient: KafkaClient, fundingService: FundingService);
    getAllInstruments(query?: GetInstrumentDto): Promise<InstrumentEntity[]>;
    getInstrumentsById(id: number): Promise<InstrumentEntity>;
    getInstrumentsBySymbol(symbol: string): Promise<InstrumentEntity>;
    getTradingRuleBySymbol(symbol: string): Promise<TradingRulesEntity>;
    createInstrument(contractDto: ContractDto): Promise<{
        newInstrument: {
            name: string;
            symbol: string;
            quoteCurrency: string;
            contractSize: string;
            lotSize: string;
            maxOrderQty: number;
            rootSymbol: string;
            contractType: ContractType;
            underlyingSymbol: string;
            makerFee: string;
            takerFee: string;
            tickSize: string;
            maxPrice: string;
            minPriceMovement: string;
            maxFiguresForSize: string;
            maxFiguresForPrice: string;
            impactMarginNotional: string;
            multiplier: string;
        } & InstrumentEntity;
        newTradingRule: {
            symbol: string;
            minPrice: string;
            limitOrderPrice: string;
            floorRatio: string;
            minOrderAmount: string;
            maxOrderAmount: string;
            minNotional: string;
            maxNotinal: string;
            liqClearanceFee: string;
            maxLeverage: number;
        } & TradingRulesEntity;
        newLeverageMargin: ({
            symbol: string;
            min: number;
            max: number;
            maxLeverage: number;
            maintenanceMarginRate: number;
            maintenanceAmount: number;
            contractType: ContractType;
        } & LeverageMarginEntity)[];
    }>;
    protected sendData(producer: Producer, topic: string, code: string, entities: {
        [key: string]: any;
    }[]): Promise<void>;
    getContractList(input: ContractListDto): Promise<{
        list: any[];
        count: number;
    }>;
    detailContract(underlyingSymbol: string): Promise<{
        instrument: any;
        tradingTier: any[];
    }>;
    updateContract(updateContractDto: UpdateContractDto): Promise<import("typeorm").UpdateResult>;
    updateInstrument(instrumentId: number, updateInstrumentDto: UpdateInstrumentDto): Promise<InstrumentEntity>;
    find(): Promise<InstrumentEntity[]>;
    findBySymbol(symbol: string): Promise<InstrumentEntity>;
    createMarketFeeByInstrument(createMarketFeeDto: CreateMarketFeeDto): Promise<MarketFeeEntity>;
    updateMarketFeeByInstrument(updateMarketFeeDto: UpdateMarketFeeDto): Promise<MarketFeeEntity>;
    getAllSymbolInstrument(): Promise<any[]>;
    getAllTickerInstrument(): Promise<any[]>;
    getAllSymbolCoinMInstrument(): Promise<any[]>;
    getIndexPrices(symbols: string[]): Promise<string[]>;
    getOraclePrices(symbols: string[]): Promise<string[]>;
    getFundingRates(symbols: string[]): Promise<string[]>;
}
