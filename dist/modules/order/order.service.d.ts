import { AdminOrderDto } from './dto/admin-order.dto';
import { HttpException, Logger } from '@nestjs/common';
import BigNumber from 'bignumber.js';
import { Producer } from 'kafkajs';
import { OrderEntity } from 'src/models/entities/order.entity';
import { OrderRepository } from 'src/models/repositories/order.repository';
import { PositionRepository } from 'src/models/repositories/position.repository';
import { AccountService } from 'src/modules/account/account.service';
import { InstrumentService } from 'src/modules/instrument/instrument.service';
import { BaseEngineService } from 'src/modules/matching-engine/base-engine.service';
import { CreateOrderDto } from 'src/modules/order/dto/create-order.dto';
import { UserService } from 'src/modules/user/users.service';
import { PaginationDto } from 'src/shares/dtos/pagination.dto';
import { ResponseDto } from 'src/shares/dtos/response.dto';
import { CANCEL_ORDER_TYPE, ContractType, OrderStatus, ORDER_TPSL } from 'src/shares/enums/order.enum';
import { KafkaClient } from 'src/shares/kafka-client/kafka-client';
import { OrderHistoryDto } from './dto/order-history.dto';
import { OpenOrderDto } from './dto/open-order.dto';
import { UserMarginModeRepository } from 'src/models/repositories/user-margin-mode.repository';
import { IUserAccount } from './interface/account-user.interface';
import { InstrumentRepository } from 'src/models/repositories/instrument.repository';
import { UpdateTpSlOrderDto } from './dto/update-tpsl-order.dto';
import { TradeRepository } from 'src/models/repositories/trade.repository';
import { Cache } from 'cache-manager';
import { AccountRepository } from 'src/models/repositories/account.repository';
import { RedisService } from 'nestjs-redis';
import { TradingRulesService } from '../trading-rules/trading-rule.service';
import { TradingRulesRepository } from 'src/models/repositories/trading-rules.repository';
import { UserRepository } from 'src/models/repositories/user.repository';
export declare class OrderService extends BaseEngineService {
    readonly logger: Logger;
    readonly orderRepoReport: OrderRepository;
    readonly tradeRepoReport: TradeRepository;
    readonly orderRepoMaster: OrderRepository;
    readonly positionRepoReport: PositionRepository;
    readonly instrumentRepoReport: InstrumentRepository;
    readonly userMarginModeRepoReport: UserMarginModeRepository;
    readonly kafkaClient: KafkaClient;
    readonly instrumentService: InstrumentService;
    readonly accountService: AccountService;
    readonly userService: UserService;
    private cacheManager;
    readonly accountRepoReport: AccountRepository;
    readonly accountRepoMaster: AccountRepository;
    private readonly redisService;
    private readonly tradingRulesService;
    readonly tradingRulesRepoReport: TradingRulesRepository;
    private cacheService;
    readonly userRepoReport: UserRepository;
    constructor(logger: Logger, orderRepoReport: OrderRepository, tradeRepoReport: TradeRepository, orderRepoMaster: OrderRepository, positionRepoReport: PositionRepository, instrumentRepoReport: InstrumentRepository, userMarginModeRepoReport: UserMarginModeRepository, kafkaClient: KafkaClient, instrumentService: InstrumentService, accountService: AccountService, userService: UserService, cacheManager: Cache, accountRepoReport: AccountRepository, accountRepoMaster: AccountRepository, redisService: RedisService, tradingRulesService: TradingRulesService, tradingRulesRepoReport: TradingRulesRepository, cacheService: Cache, userRepoReport: UserRepository);
    getOpenOrderByAccountId(paging: PaginationDto, userId: number, openOrderDto: OpenOrderDto): Promise<ResponseDto<OrderEntity[]>>;
    getOrderByAdmin(paging: PaginationDto, queries: AdminOrderDto): Promise<ResponseDto<OrderEntity[]>>;
    getOneOrder(orderId: number, userId: number): Promise<OrderEntity>;
    setCacheEnableOrDisableCreateOrder(status: boolean): Promise<void>;
    createOrder(createOrderDto: CreateOrderDto, { accountId, userId, email }: IUserAccount): Promise<OrderEntity>;
    getRootOrder(accountId: number, orderId: number, type: ORDER_TPSL): Promise<OrderEntity>;
    findOrderBatch(status: OrderStatus, fromId: number, count: number): Promise<OrderEntity[]>;
    findAccountOrderBatch(userId: number, status: OrderStatus, fromId: number, count: number, types: string[], cancelOrderType: CANCEL_ORDER_TYPE, contractType: ContractType): Promise<OrderEntity[]>;
    cancelOrder(orderId: number, userId: number): Promise<OrderEntity>;
    cancelAllOrder(userId: number, cancelOrderType: CANCEL_ORDER_TYPE, contractType: ContractType): Promise<OrderEntity[]>;
    sendDataCancelToKafka(statuses: OrderStatus[], userId: number, types: string[], cancelOrderType: CANCEL_ORDER_TYPE, contractType: ContractType): Promise<any[]>;
    cancelOrderByStatus(userId: number, status: OrderStatus, producer: Producer, types: string[], cancelOrderType: CANCEL_ORDER_TYPE, contractType: ContractType): Promise<void>;
    getLastOrderId(): Promise<number>;
    getHistoryOrders(userId: number, paging: PaginationDto, orderHistoryDto: OrderHistoryDto): Promise<{
        data: OrderEntity[];
        metadata: {
            totalPage: number;
        };
    }>;
    validateOrder(createOrder: CreateOrderDto): Promise<CreateOrderDto>;
    validatePrecision(value: string | BigNumber, precision: string | BigNumber): boolean;
    validateMinMaxPrice(createOrderDto: CreateOrderDto): Promise<void>;
    getTpSlOrder(rootOrderId: number): Promise<HttpException | {
        rootOrder: OrderEntity;
        tpOrder: OrderEntity;
        slOrder: OrderEntity;
    }>;
    updateTpSlOrder(userId: number, updateTpSlOrder: UpdateTpSlOrderDto[], rootOrderId: number): Promise<void>;
    private removeEmptyValues;
    calOrderMargin(accountId: number, asset: string): Promise<any>;
    updateUserIdInOrder(): Promise<void>;
    updateUserEmailInOrder(): Promise<void>;
}
