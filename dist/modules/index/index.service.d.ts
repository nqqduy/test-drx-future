import { Cache } from 'cache-manager';
import { RedisService } from 'nestjs-redis';
import { MarketDataRepository } from 'src/models/repositories/market-data.repository';
import { MarketIndexRepository } from 'src/models/repositories/market-indices.repository';
import { MetadataRepository } from 'src/models/repositories/metadata.repository';
import { FundingService } from 'src/modules/funding/funding.service';
import { MetadataCandleDTO, MetadataMarketDTO, MetadataWeightGroupDTO } from 'src/modules/index/dto/index.dto';
import { MarketCrawler } from 'src/modules/index/markets/base';
import { InstrumentService } from 'src/modules/instrument/instrument.service';
import { OrderbookService } from 'src/modules/orderbook/orderbook.service';
import { HttpClient } from 'src/shares/http-clients/https.client';
import { KafkaClient } from 'src/shares/kafka-client/kafka-client';
import { Connection } from 'typeorm';
export declare class IndexService {
    private marketDataRepositoryMaster;
    private marketDataRepositoryReport;
    private marketIndexRepositoryMaster;
    private marketIndexRepositoryReport;
    private metaRepositoryMaster;
    private metaRepositoryReport;
    private cacheService;
    private readonly redisService;
    private connection;
    private readonly httpClient;
    private readonly kafkaClient;
    private readonly instrumentService;
    private readonly orderbookService;
    private readonly fundingService;
    private cacheManager;
    private readonly logger;
    private metaMarket;
    private metaCandle;
    private metaWeight;
    private instrumentMap;
    constructor(marketDataRepositoryMaster: MarketDataRepository, marketDataRepositoryReport: MarketDataRepository, marketIndexRepositoryMaster: MarketIndexRepository, marketIndexRepositoryReport: MarketIndexRepository, metaRepositoryMaster: MetadataRepository, metaRepositoryReport: MetadataRepository, cacheService: Cache, redisService: RedisService, connection: Connection, httpClient: HttpClient, kafkaClient: KafkaClient, instrumentService: InstrumentService, orderbookService: OrderbookService, fundingService: FundingService, cacheManager: Cache);
    syncMarketData(): Promise<void>;
    getBase(market: string): MarketCrawler;
    getCurrentFuturePrice(): Promise<void>;
    requestIndexPrice(base: MarketCrawler, market: string, index: number, requestUrl: string): Promise<void>;
    updateIndexPrice(): Promise<void>;
    getIndexPrices(symbols: string[]): Promise<string[]>;
    getOraclePrices(symbols: string[]): Promise<string[]>;
    getLastUpdate(): Promise<number | undefined>;
    getUpdateCount(): Promise<number | undefined>;
    getUpdateError(): Promise<string | undefined>;
    saveIndexPrice(symbol: string, price: string): Promise<void>;
    saveOraclePrice(symbol: string, price: string): Promise<void>;
    getMetaCandle(): Promise<MetadataCandleDTO>;
    getMetaWeight(): Promise<MetadataWeightGroupDTO>;
    getMetaMarket(): Promise<MetadataMarketDTO>;
    initMeta(name: string, data: string): Promise<void>;
    _updateMeta(name: string, data: string): Promise<void>;
    updateMeta(): Promise<void>;
    loadMeta(): Promise<void>;
    private loadInstruments;
    private getMovingAveragePrice;
    private calculateOraclePrice;
    fakeMarkPrice(oraclePrice: any, symbol: any): Promise<string>;
    saveOraclePriceBySymbol(symbol: string, price: string): Promise<void>;
}
